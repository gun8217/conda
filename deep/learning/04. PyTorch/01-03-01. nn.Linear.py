import torch
import torch.nn as nn

test_input = torch.randn(size=(16, 8))

fc = nn.Linear(in_features=8, out_features=4)

test_output = fc(test_input)

print(f"test input: {test_input.shape}")
print(f"test output: {test_output.shape}")


# 먼저, 주어진 코드에서 입력 텐서와 전결합층을 설정합니다.

# python
# 코드 복사
# test_input = torch.randn(size=(16, 8))  # 16개의 샘플, 각 샘플은 8개의 특성
# fc = nn.Linear(in_features=8, out_features=4)  # 8개의 입력을 받아 4개의 출력 생성
# **입력 텐서 test_input**의 크기는 16x8입니다. 즉, 16개의 샘플이 각각 8개의 특성을 가지고 있습니다.

# 16: 샘플의 개수 (샘플 16개)
# 8: 각 샘플의 특성 개수 (각 샘플은 8개의 특성값을 가짐)
# **전결합층 fc**은 8개의 입력을 받아 4개의 출력을 생성하는 레이어입니다. 이 레이어는 8x4 크기의 가중치 행렬을 가지고 있습니다.

# 8: 입력 특성의 개수 (입력값은 8개의 특성을 가짐)
# 4: 출력 특성의 개수 (출력값은 4개의 특성값을 가짐)


# 2. 전결합층의 행렬 곱셈
# 전결합층을 통과하는 과정을 행렬 곱셈으로 생각할 수 있습니다. 이를 좀 더 명확히 이해하기 위해 간단한 예시를 들어 설명해보겠습니다.

# 예시: 작은 입력 텐서
# 예를 들어, 1개의 샘플이 3개의 특성을 가진 경우(input = [x1, x2, x3])를 생각해봅시다.
# 이 샘플을 3개의 입력 특성을 가지는 전결합층에 넣으면, 4개의 출력을 얻을 수 있습니다.
# python
# 코드 복사
# input = [x1, x2, x3]  # 입력값 (1개 샘플, 3개 특성)

# # 전결합층의 가중치 행렬 (3개의 입력을 받아 4개의 출력을 생성)
# weight = [
#     [w1, w2, w3],  # 출력 뉴런 1
#     [w4, w5, w6],  # 출력 뉴런 2
#     [w7, w8, w9],  # 출력 뉴런 3
#     [w10, w11, w12] # 출력 뉴런 4
# ]

# # 편향 (각 출력 뉴런에 하나씩 편향을 추가)
# bias = [b1, b2, b3, b4]  # 각 출력 뉴런에 대한 편향
# 이제, 행렬 곱셈을 통해 출력값을 계산해봅니다. 입력 벡터와 가중치 행렬을 곱하고, 편향을 더하면 됩니다.

# 행렬 곱셈:

# 입력 텐서와 가중치 행렬을 곱한 후, 각 출력에 대한 편향을 더합니다.

# 첫 번째 출력 뉴런(y1)은 다음과 같이 계산됩니다:

# scss
# 코드 복사
# y1 = (x1 * w1) + (x2 * w2) + (x3 * w3) + b1
# 두 번째 출력 뉴런(y2)은:

# scss
# 코드 복사
# y2 = (x1 * w4) + (x2 * w5) + (x3 * w6) + b2
# 세 번째 출력 뉴런(y3)은:

# scss
# 코드 복사
# y3 = (x1 * w7) + (x2 * w8) + (x3 * w9) + b3
# 네 번째 출력 뉴런(y4)은:

# scss
# 코드 복사
# y4 = (x1 * w10) + (x2 * w11) + (x3 * w12) + b4
# 최종 출력: 따라서, 1개의 샘플에 대해 계산된 4개의 출력값은 [y1, y2, y3, y4]입니다.

# 이와 같은 방식으로 여러 샘플에 대해 출력값을 계산할 수 있습니다.


# 3. 16개의 샘플에 대해서
# 이제 16개의 샘플에 대해 동일한 작업을 수행한다고 생각해봅시다. 각 샘플은 8개의 입력 특성을 가지며, 전결합층은 4개의 출력 뉴런을 생성합니다.

# 입력 텐서 test_input의 크기는 16x8입니다.
# 즉, 16개의 샘플이 있고, 각 샘플은 8개의 특성을 가지고 있습니다.
# 전결합층은 8개의 입력에 대해 4개의 출력을 생성합니다.
# 이 전결합층은 8x4 크기의 가중치 행렬을 가지고 있습니다.
# 따라서, test_input과 가중치 행렬을 행렬 곱셈을 하게 되면:

# **입력 텐서 test_input**은 16x8 크기입니다.
# **가중치 행렬 fc.weight**는 8x4 크기입니다.
# 행렬 곱셈을 수행하면 결과는 16x4 크기의 텐서가 됩니다. 즉, 16개의 샘플 각각에 대해 4개의 출력값이 생성됩니다.


# 4. 행렬 곱셈 공식
# 행렬 곱셈에서 A가 16x8 크기이고, B가 8x4 크기일 때, 결과 행렬 C는 16x4 크기입니다.

# A와 B를 곱하면:
# A[i, :]는 test_input의 i번째 샘플의 8개의 특성입니다.
# B[:, j]는 가중치 행렬에서 j번째 출력 뉴런에 해당하는 8개의 가중치입니다.
# 따라서 C[i, j]는 i번째 샘플에 대해 j번째 출력 뉴런을 계산하는 값입니다.

# **최종 출력 텐서 test_output**은 16x4 크기로, 16개의 샘플 각각에 대해 4개의 출력값을 가지게 됩니다.


# 5. 결과
# python
# 코드 복사
# print(f"test input: {test_input.shape}")  # 출력: torch.Size([16, 8])
# print(f"test output: {test_output.shape}")  # 출력: torch.Size([16, 4])
# test_input.shape: 16x8
# 16개의 샘플, 각 샘플은 8개의 특성을 가짐.
# test_output.shape: 16x4
# 16개의 샘플 각각에 대해 4개의 출력값이 생성됩니다.